# ------------------------------------------------------------------------------     
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------     
def start_board():
    ip = mycontext['ip']
    port = mycontext['port']
    print "Listening on IP " + str(ip) +" port " + str(port)
    try: 
        listencommhandle = waitforconn(ip, port, board_connection_handler)
    except Exception, e:
        print "Exception in start_board: %s, %s\n" %(type(e), e)
        raise
        #pass

# ------------------------------------------------------------------------------             
# Called when an incoming message is received. 
# --> Important starting point
# ------------------------------------------------------------------------------             
def board_connection_handler(ip, port, sockobj, thiscommhandle, listencommhandle):
    try:
        msgheader = sockobj.recv(1024) # Receive message
        
        # React depending on message type: HTTP GET or POST, or some other type of communication.
        if msgheader.startswith( 'GET' ):
            get_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'POST' ):
            post_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'ADD' ):
            resolve_add_board(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'MODIFY' ):
            resolve_modify_board(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'DELETE' ):
            resolve_delete_board(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'REJOIN' ):
            rejoin_network_handler(msgheader, sockobj, thiscommhandle)
        else:
            print '****Request:\n%s' % msgheader
            other_requests_handler(msgheader, sockobj, thiscommhandle)

    except Exception, e:
        print "Exception in board: %s, %s\n" %(type(e), e)
        #raise

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_board_handler(msgheader, sockobj, thiscommhandle):
    htmlresponse = generate_html_page()
    res=make_http_response(200, 'OK', htmlresponse)
    sockobj.send(res)
    stopcomm(thiscommhandle) 

# ------------------------------------------------------------------------------
# Handles rejoin requests from other nodes that has reconnected to this node
# Here we compare their current boardstate and resends the parts that they are
# missing. We assume that this node has also realised that it has regained
# communication with the sending node, so we edit our board, even though it
# may differ from the other node's
# ------------------------------------------------------------------------------
def rejoin_network_handler(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    sender = lines[1]

    sockobj.send("OK")
    stopcomm(thiscommhandle)

    lock()
    try:
        # Create deep copy of our boardstate
        board = {}
        for origin in mycontext['entries']:
            board[origin] = {}
            for msgid in mycontext['entries'][origin]:
                board[origin][msgid] = {}
                for key in mycontext['entries'][origin][msgid]:
                    board[origin][msgid][key] = mycontext['entries'][origin][msgid][key]

        # Find out what we should notify them about
        for line in lines[2:]:
            if line.startswith("DELETED "):
                line = line.split()[1]
                msgid, origin, = line.split("@")
                msgid = int(msgid)
                if origin in board and msgid in board[origin]:
                    del board[origin][msgid]
                continue
            msgid, origin, msgver, author = line.split("@")
            msgid = int(msgid)
            msgver = int(msgver)
            if origin in board and msgid in board[origin]:
                if board[origin][msgid]['deleted']:
                    continue
                elif board[origin][msgid]['msgver'] == msgver:
                    if author > board[origin][msgid]['author']:
                        del board[origin][msgid]
                elif board[origin][msgid]['msgver'] < msgver:
                    del board[origin][msgid]
    finally:
        unlock()

    # Notify the sender
    ssplit = sender.split(":")
    ipport = {'ip': ssplit[0], 'port': int(ssplit[1])}
    for origin in board:
        for msgid in board[origin]:
            entry = board[origin][msgid]
            if entry['deleted']:
                msg = "DELETE\n%s\n%d" % (origin, msgid)
            else:
                msg = "MODIFY\n%s\n%d\n%d\n%s\n%s" \
                    % (origin, msgid, entry['msgver'], entry['author'], entry['msg'])
            send_to([ ipport ], msg)

# ------------------------------------------------------------------------------
# topology must be valid.
# Sets a new topology, and issues a request to all reconnected nodes for
# any information we might not have.
# ------------------------------------------------------------------------------
def set_topology(topName):
    snapshot = []
    rejoin = []
    lock()
    try:
        oldTop = mycontext['neighborlist']
        newTop = mycontext['topologies'][topName]
        mycontext['neighborlist'] = newTop
        mycontext['topology'] = topName
        print "New topology: %s" % topName
        for ipport in newTop:
            if ipport not in oldTop:
                rejoin.append(ipport)
        if rejoin:
            snapshot = [ "REJOIN", my_origin() ]
            for origin in mycontext['entries']:
                for msgid in mycontext['entries'][origin]:
                    if is_entry_deleted(origin, msgid):
                        msg = "DELETED %d@%s" % (msgid, origin)
                    else:
                        msgver = mycontext['entries'][origin][msgid]['msgver']
                        author = mycontext['entries'][origin][msgid]['author']
                        msg = "%d@%s@%d@%s" % \
                            (msgid, origin, msgver, author)
                    snapshot.append(msg)
    finally:
        unlock()
    if snapshot:
        send_to(rejoin, "\n".join(snapshot))

# ------------------------------------------------------------------------------
# Handles entry POSTing requests to the blackboard.
# ------------------------------------------------------------------------------
def post_board_handler(msgheader, sockobj, thiscommhandle):
    template = '<html><head><style>.status {color: %s;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
    query = extract_http_request_contents(msgheader)
    params = extract_parameters_from_query(query)

    # I am sorry RESTful gods
    if 'set_topology' in params:
        topName = params['set_topology']
        if topName not in mycontext['topologies']:
            htmlresponse = template % ("red", "No such topology")
            res = make_http_response(404, 'File not found', htmlresponse)
            sockobj.send(res)
            stopcomm(thiscommhandle)
        else:
            htmlresponse = template % ("green", "Nice meme")
            res = make_http_response(200, 'Ok', htmlresponse)
            sockobj.send(res)
            stopcomm(thiscommhandle)
            set_topology(topName)
        return

    if 'entry' not in params:
        htmlresponse = template % ("red", "No entry in POST")
        res = make_http_response(400, 'Bad Request', htmlresponse)
        sockobj.send(res)
        stopcomm(thiscommhandle)
        return

    if 'delete' in params or 'return_id' not in params:
        # No reason to keep the browser waiting
        htmlresponse = template % ("green", "Request received")
        res = make_http_response(202, 'Accepted', htmlresponse)
        sockobj.send(res)
        stopcomm(thiscommhandle)

    # Extract msgid and msg
    msg = params['entry']
    msg_urlencoded = urllib_quote_plus(msg)

    # Should we add, modify or delete?
    cmd = None
    lock()
    try:
        if 'delete' in params:
            msgid, origin = params['id'].split('@')
            msgid = int(msgid)
            if not is_entry_deleted(origin, msgid):
                if params['delete'] == '1':
                    mark_entry_deleted(origin, msgid)
                    cmd = "DELETE\n%s\n%d" % (origin, msgid)
                else:
                    msgver = mycontext['entries'][origin][msgid]['msgver']
                    author = my_origin() 
                    set_entry(origin, msgid, msgver + 1, author, msg)
                    cmd = "MODIFY\n%s\n%d\n%d\n%s\n%s" \
                        % (origin, msgid, msgver + 1, author, msg)
        else:
            origin = my_origin()
            msgid = get_and_increment_clock()
            set_entry(origin, msgid, 0, origin, msg)
            cmd = "ADD\n%s\n%d\n%s" % (origin, msgid, msg)
            if 'return_id' in params:
                # For use with lab3postscript.sh
                sockobj.send("%d@%s" % (msgid, origin))
                stopcomm(thiscommhandle)
            nentries = count_entries()
            if nentries == 1:
                mycontext['post_begin'] = getruntime()
            else:
                mycontext['post_end'] = getruntime()
    finally:
        unlock()

    # Reduce the amount of "deadlocking" by unlocking before starting network stuff
    if cmd is not None:
        send_neighbors(cmd)

# ------------------------------------------------------------------------------
# Send msg to all _other_ neighbors
# ------------------------------------------------------------------------------
def send_neighbors(msg):
    send_to(mycontext['neighborlist'], msg)

# ------------------------------------------------------------------------------
# Send msg to nodes
# ------------------------------------------------------------------------------
def send_to(nodes, msg):
    unsent = []
    for neighbor in nodes:
        unsent.append({'ip': neighbor['ip'], 'port': neighbor['port'], 'msg': msg})
    spawn_new = False
    mycontext['send_lock'].acquire()
    try:
        threads = mycontext['send_threads']
        maxthreads = mycontext['outsockets']
        if threads < maxthreads:
            mycontext['send_threads'] += 1
            spawn_new = True
        mycontext['send_queue'] += unsent
    finally:
        mycontext['send_lock'].release()
    if spawn_new:
        thread_send_to()

def thread_send_to():
    unsent = None
    while True:
        if unsent is None:
            mycontext['send_lock'].acquire()
            try:
                if not mycontext['send_queue']:
                    mycontext['send_threads'] -= 1
                    return
                unsent = mycontext['send_queue'][0]
                mycontext['send_queue'] = mycontext['send_queue'][1:]
            finally:
                mycontext['send_lock'].release()
        status = send_to_guarded(unsent)
        if status == "ok":
            unsent = None
            continue
        elif status == "outsockets":
            mycontext['send_lock'].acquire()
            try:
                mycontext['send_threads'] -= 1
                mycontext['outsockets'] -= 1
                mycontext['send_queue'].insert(0, unsent)
                print "Outsockets limit: %d" % mycontext['outsockets']
                return
            finally:
                mycontext['send_lock'].release()
        elif status == "retry":
            continue

def send_to_guarded(unsent):
    try:
        nsock = openconn(unsent['ip'], unsent['port'])
        nsock.send(unsent['msg'])
        nsock.recv(2)
        nsock.close()
        return "ok"
    except Exception, e:
        if str(e) == "Resource 'outsockets' limit exceeded!!":
            return "outsockets"
        elif str(e) == "Connection timed out!" or \
                str(e) == "timed out":
            print "%s [%s:%d]" % (e, unsent['ip'], unsent['port'])
            return "retry"
        else:
            print "Exception in send_to_guarded: %s, %s [%s:%d]\n" \
                %(type(e), e, unsent['ip'], unsent['port'])
            return "ok"

# ------------------------------------------------------------------------------
# Locks the board
# ------------------------------------------------------------------------------
def lock():
    mycontext['lock'].acquire()

# ------------------------------------------------------------------------------
# Unlocks the board
# ------------------------------------------------------------------------------
def unlock():
    mycontext['lock'].release()

# ------------------------------------------------------------------------------
# Returns this nodes ip and port as a string
# ------------------------------------------------------------------------------
def my_origin():
    return "%s:%d" % (mycontext['ip'], mycontext['port'])

# ------------------------------------------------------------------------------
# Increments the logic clock, and returns the previous value
# ------------------------------------------------------------------------------
def get_and_increment_clock():
    clock = mycontext['logic_clock']
    mycontext['logic_clock'] = clock + 1
    return clock

# ------------------------------------------------------------------------------
# Updates the clock if newclock is larger
# ------------------------------------------------------------------------------
def try_update_clock(newclock):
    if mycontext['logic_clock'] <= newclock:
        mycontext['logic_clock'] = newclock + 1

# ------------------------------------------------------------------------------
# Updates an entry on the local board
# ------------------------------------------------------------------------------
def set_entry(origin, msgid, msgver, author, msg):
    mycontext['entries'][origin][msgid] = {
        'msgver': msgver,
        'author': author,
        'msg': msg,
        'deleted': False
    }

# ------------------------------------------------------------------------------
# Checks if an entry is marked as deleted 
# ------------------------------------------------------------------------------
def is_entry_deleted(origin, msgid):
    return mycontext['entries'][origin][msgid]['deleted']

# ------------------------------------------------------------------------------
# Modifies an entry if it is "more recent"
# Returns true if the action should be reposted
# ------------------------------------------------------------------------------
def try_modify_entry(origin, msgid, msgver, author, msg):
    if msgid not in mycontext['entries'][origin]:
        set_entry(origin, msgid, msgver, author, msg)
        return True
    if is_entry_deleted(origin, msgid):
        return False

    oldmsg = mycontext['entries'][origin][msgid]
    if msgver == oldmsg['msgver']:
        if oldmsg['author'] < author:
            set_entry(origin, msgid, msgver, author, msg)
            return True
    elif msgver > oldmsg['msgver']:
        set_entry(origin, msgid, msgver, author, msg)
        return True
    return False

# ------------------------------------------------------------------------------
# Marks an entry as deleted, regardless if it exists or not
# ------------------------------------------------------------------------------
def mark_entry_deleted(origin, msgid):
    mycontext['entries'][origin][msgid] = {'deleted': True}

def count_entries():
    count = 0
    for origin in mycontext['entries']:
        count += len(mycontext['entries'][origin])
    return count

# ------------------------------------------------------------------------------
# Handles syncing new entries between clients
# ------------------------------------------------------------------------------
def resolve_add_board(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    origin = lines[1]
    msgid = int(lines[2])
    msg = lines[3]
    
    sockobj.send('OK')
    stopcomm(thiscommhandle)

    repost = False
    lock()
    try:
        if msgid not in mycontext['entries'][origin]:
            set_entry(origin, msgid, 0, origin, msg)
            try_update_clock(msgid)
            repost = True
            nentries = count_entries()
            if nentries == 1:
                mycontext['post_begin'] = getruntime()
            else:
                mycontext['post_end'] = getruntime()
    finally:
        unlock()

    #if repost:
        #send_neighbors(msgheader)

# ------------------------------------------------------------------------------
# Handles syncing changes to entries between clients
# ------------------------------------------------------------------------------
def resolve_modify_board(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    origin = lines[1]
    msgid = int(lines[2])
    msgver = int(lines[3])
    author = lines[4]
    msg = lines[5]

    sockobj.send('OK')
    stopcomm(thiscommhandle)

    repost = False
    lock()
    try:
        if try_modify_entry(origin, msgid, msgver, author, msg):
            try_update_clock(msgid)
            repost = True
    finally:
        unlock()

    #if repost:
        #send_neighbors(msgheader)

# ------------------------------------------------------------------------------
# Handles deleting entries between clients
# ------------------------------------------------------------------------------
def resolve_delete_board(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    origin = lines[1]
    msgid = int(lines[2])

    sockobj.send('OK')
    stopcomm(thiscommhandle)

    repost = False
    lock()
    try:
        if msgid not in mycontext['entries'][origin] or not is_entry_deleted(origin, msgid):
            mark_entry_deleted(origin, msgid)
            try_update_clock(msgid)
            repost = True
    finally:
        unlock()

    #if repost:
        #send_neighbors(msgheader)

# ------------------------------------------------------------------------------
# Handles other requests, outputs 404
# ------------------------------------------------------------------------------
def other_requests_handler(msgheader, sockobj, thiscommhandle):
    # extract the query from the HTTP request 
    query = extract_http_request_contents(msgheader)
    print query
    # extract the query parameters
    parameters = extract_parameters_from_query(query)
    print parameters
    print parameters['entry']
    
    # Do not mix HTML code with the server code as done here. This is a bad practice
    template='<html><head><style>.status {color: red;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
    htmlresponse = template % ("404 Not Found\n" + msgheader)
    res=make_http_response(404, 'Not Found', htmlresponse)
    sockobj.send(res)
    stopcomm(thiscommhandle) 

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_response(status, status_text, htmlresponse):
    response_template = "HTTP/1.1 %d %s\r\nContent-type: text/html\r\nContent-length: %i\r\n\r\n%s"
    return response_template % (status, status_text, len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
    # find content length
    conent_length = header.split('Content-Length: ')[1]
    conent_length = int(conent_length.split('\r\n')[0])
    
    # extract the http response body and discard the header
    contetns = header[-conent_length:]
    return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
    # extract the query parameters as a dictionary: {name:value}
    # example input format: comment=aa&ip=127.0.0.1&port=63101&action=Delete
    parameters={}
    arr = msg.split('&')
    for a in arr:
        pp = a.split('=')
        if len(pp)>1:
            parameters[pp[0]] = urllib_unquote_plus(pp[1])
    return parameters

# ------------------------------------------------------------------------------
# Outputs the blackboard html 
# ------------------------------------------------------------------------------     
def generate_html_page():
    #Initialize blackboard content
    
    entries = []
    #for msgid in range(mycontext['logic_clock'] + 1):
    #    for origin in mycontext['entries']:
    #        if msgid not in mycontext['entries'][origin] or is_entry_deleted(origin, msgid):
    #            continue
    #        msg = mycontext['entries'][origin][msgid]
    #        boardid = "%d@%s" % (msgid, origin)
    #        entries.append(mycontext['entry_template'] \
    #            %('entries/%s' % (boardid), boardid, msg['msg']))
    entriesStr = "".join(entries)

    # dynamic title showing Ip address, port, up time and current topology. 
    title='Segmented network @ %s:%d. Up time: %ds' %( str(mycontext['ip']), mycontext['port'], int(getruntime()) )
    nentries = count_entries()
    if nentries == 0:
        consistent = "N/A"
    else:
        consistent = "%ds" % (mycontext['post_end'] - mycontext['post_begin'])
    sendqueue = len(mycontext['send_queue'])
    if sendqueue > 0:
        queue = ", Message queue: %d" % sendqueue
    else:
        queue = ""
    topName = "Topology: %s, Total entries: %d, TTC: %s%s" % (mycontext['topology'], nentries, consistent, queue)
    content = mycontext['boardcontents_template'] %( title, topName, entriesStr )
    fullpage_h = mycontext['frontpage_header_template'] + content
    fullpage = fullpage_h + mycontext['frontpage_footer_template'] % mycontext['authors']
    #print entriesStr, content, fullpage
    return fullpage
    

# ----------------------------------------------------------------------------
# Used by initialize func when parsing topology.
# Responsible for populating mycontext['entries'] with subboards.
# ----------------------------------------------------------------------------
def parse_ipport_str(ipport, ignoreself=True):
    mycontext['entries'][ipport] = {}
    ipport = ipport.split(':')
    nip = ipport[0]
    nport = int(ipport[1])
    ipport = {'ip': nip, 'port': nport}
    return ipport

# ------------------------------------------------------------------------------             
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens a socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
    # whenever this vessel gets a connection on its IP:port it'll call function board_connection_handler
    if len(callargs) == 1 or len(callargs) == 2:
        port = int(callargs[0])
        if len(callargs) == 2:
            ip=str(callargs[1])
        else:
            try:
             ip = getmyip()
            except Exception, e:
             print "Could not get an IP\n"
             print (type(e), e)
             raise
    
    # Fail if we don't have 1 or 2 arguments    
    else:
        raise Exception("Usage: python <path to repy.py> <path to restrictions.default> skeleton2016.repy <port> [ip (optional)]")


    #Initialize Port and IP
    mycontext['port'] = port
    mycontext['ip'] = ip
    
    #read html template files
    mycontext['entry_template'] = file("entry_template.html").read()
    mycontext['boardcontents_template'] = file("boardcontents_template.html").read()
    mycontext['frontpage_header_template'] = file("board_frontpage_header_template.html").read()
    mycontext['frontpage_footer_template'] = file("board_frontpage_footer_template.html").read()
 
    mycontext['entries'] = {"%s:%d" % (ip, port): {}}
    mycontext['send_lock'] = getlock()
    mycontext['send_queue'] = []
    mycontext['send_threads'] = 0
    mycontext['outsockets'] = 20
    print "Outsockets limit: %d" % 20

    # Read neighbors
    mycontext['neighborlist'] = []

    rawlines = file("topologies.txt").read().splitlines()
    lines = []
    for iLine in range(len(rawlines)):
        line = rawlines[iLine].strip()
        if line and line[0] != "#":
            lines.append(line)

    myipport = {'ip': ip, 'port': port}
    iLine = 0
    segments = {}
    topologies = {}
    while iLine < len(lines):
        # SEGMENTs should be defined at the beginning of the file
        if lines[iLine].startswith("SEGMENT "):
            segName = lines[iLine].split()[1]
            segments[segName] = []
            iLine += 1
            while lines[iLine] != "END":
                segments[segName].append(parse_ipport_str(lines[iLine]))
                iLine += 1
        # TOPOLOGYs should be defined at the end of the file
        # If it is not some segments might not have been parsed when the topology is created
        elif lines[iLine].startswith("TOPOLOGY "):
            topName = lines[iLine].split()[1]
            topologies[topName] = []
            iLine += 1
            while lines[iLine] != "END":
                top = []
                for segip in lines[iLine].split():
                    if segip in segments:
                        # Expand segment
                        top += segments[segip]
                    else:
                        # Should be an ip, or the file is borked
                        top.append(parse_ipport_str(segip))
                iLine += 1
                if myipport in top:
                    # We are a part of this topology
                    top.remove(myipport)
                    for ipport in top:
                        if ipport not in topologies[topName]:
                            topologies[topName].append(ipport)
        # DEFAULT must come after the referenced topology
        elif lines[iLine].startswith("DEFAULT "):
            topName = lines[iLine].split()[1]
            mycontext['neighborlist'] = topologies[topName]
            mycontext['topology'] = topName
            print "Default topology: %s" % topName
        else:
            print "TOPOLOGY PARSER: Unknown string: %s" % lines[iLine]
        iLine += 1
    mycontext['topologies'] = topologies

    for top in mycontext['topologies']:
        print "Topology: %s" % top
        for origin in mycontext['topologies'][top]:
            print "  %s:%d" % (origin['ip'], origin['port'])
        print ""

    # Create local board lock and logic clock
    mycontext['lock'] = getlock()
    mycontext['logic_clock'] = 0

    mycontext['authors'] = "Rafael Mohlin (mrafael@student.chalmers.se)"

    # e = Exception("ex");
    # try:
    # print "%s, %s\n" %(type(e), e)
    # except Exception, ee:
    # print ee

    start_board()

# ----------------------------------------------------------------------------
# urllib.repy
# include urllib.repy doesn't work, if fails with the error
# Exception (with type 'exceptions.ValueError'): Code failed safety check! Error: ("<type 'exceptions.SyntaxError'> invalid syntax (line lineNrAfterIncludeStatment)",)

def urllib_quote(inputstring, safestring="/"):
  """
  <Purpose>
    Encode an inputstring such that it can be used safely in a URL or XML
    document.

  <Arguments>
    inputstring:
           The string to urlencode.

    safestring (optional):
           Specifies additional characters that should not be quoted --
           defaults to "/".

  <Exceptions>
    TypeError if the inputstring or safestring parameters aren't strings.

  <Side Effects>
    None.

  <Returns>
    Urlencoded version of the passed string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_quote's inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  if type(safestring) is not str:
    raise TypeError("urllib_quote's safestring parameter must be a string, not '"+str(type(safestring))+"'")
  

  resultstr = ""

  # We go through each character in the string; if it's not in [0-9a-zA-Z]
  # we wrap it.

  safeset = set(safestring)

  for char in inputstring:
    asciicode = ord(char)
    if (asciicode >= ord("0") and asciicode <= ord("9")) or \
        (asciicode >= ord("A") and asciicode <= ord("Z")) or \
        (asciicode >= ord("a") and asciicode <= ord("z")) or \
        asciicode == ord("_") or asciicode == ord(".") or \
        asciicode == ord("-") or char in safeset:
      resultstr += char
    else:
      resultstr += "%%%02X" % asciicode

  return resultstr




def urllib_quote_plus(inputstring, safestring=""):
  """
  <Purpose>
    Encode a string to go in the query fragment of a URL.

  <Arguments>
    inputstring:
           The string to urlencode.

    safestring (optional):
           Specifies additional characters that should not be quoted --
           defaults to the empty string.

  <Exceptions>
    TypeError if the inputstring or safestring parameters aren't strings.

  <Side Effects>
    None.

  <Returns>
    Urlencoded version of the passed string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_quote_plus' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  if type(safestring) is not str:
    raise TypeError("urllib_quote_plus' safestring parameter must be a string, not '"+str(type(safestring))+"'")
  

  return urllib_quote(inputstring, safestring + " ").replace(" ", "+")




def urllib_unquote(inputstring):
  """
  <Purpose>
    Unquote a urlencoded string.

  <Arguments>
    inputstring:
           The string to unquote.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError thrown if the last wrapped octet isn't a valid wrapped octet
    (i.e. if the string ends in "%" or "%x" rather than "%xx". Also throws
    ValueError if the nibbles aren't valid hex digits.

  <Side Effects>
    None.

  <Returns>
    The decoded string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_unquote's inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  

  resultstr = ""

  # We go through the inputstring from end to beginning, looking for wrapped
  # octets. When one is found we add it (unwrapped) and the following
  # string to the resultant string, and shorten the original inputstring.

  while True:
    lastpercentlocation = inputstring.rfind("%")
    if lastpercentlocation < 0:
      break

    wrappedoctetstr = inputstring[lastpercentlocation+1:lastpercentlocation+3]
    if len(wrappedoctetstr) != 2:
      raise ValueError("Quoted string is poorly formed")

    resultstr = \
        chr(int(wrappedoctetstr, 16)) + \
        inputstring[lastpercentlocation+3:] + \
        resultstr
    inputstring = inputstring[:lastpercentlocation]

  resultstr = inputstring + resultstr
  return resultstr




def urllib_unquote_plus(inputstring):
  """
  <Purpose>
    Unquote the urlencoded query fragment of a URL.

  <Arguments>
    inputstring:
           The string to unquote.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError thrown if the last wrapped octet isn't a valid wrapped octet
    (i.e. if the inputstring ends in "%" or "%x" rather than "%xx". Also throws
    ValueError if the nibbles aren't valid hex digits.

  <Side Effects>
    None.

  <Returns>
    The decoded string.
  """
  if type(inputstring) is not str:
    raise TypeError("urllib_unquote_plus' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")

  return urllib_unquote(inputstring.replace("+", " "))




def urllib_quote_parameters(inputdictionary):
  """
  <Purpose>
    Encode a dictionary of (key, value) pairs into an HTTP query string or
    POST body (same form).

  <Arguments>
    dictionary:
           The dictionary to quote.

  <Exceptions>
    TypeError if the inputdictionary isn't a dict.

  <Side Effects>
    None.

  <Returns>
    The quoted dictionary.
  """
  if type(inputdictionary) is not dict:
    raise TypeError("urllib_quote_parameters' inputstringdictionary parameter must be a dict, not '"+str(type(inputstring))+"'")

  quoted_keyvals = []
  for key, val in inputdictionary.items():
    quoted_keyvals.append("%s=%s" % (urllib_quote(key), urllib_quote(val)))

  return "&".join(quoted_keyvals)




def urllib_unquote_parameters(inputstring):
  """
  <Purpose>
    Decode a urlencoded query string or POST body.

  <Arguments>
    inputstring:
           The string to decode.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError if the inputstring is poorly formed.

  <Side Effects>
    None.

  <Returns>
    A dictionary mapping keys to values.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_unquote_parameters' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")

  keyvalpairs = inputstring.split("&")
  res = {}

  for quotedkeyval in keyvalpairs:
    # Throw ValueError if there is more or less than one '='.
    quotedkey, quotedval = quotedkeyval.split("=")
    key = urllib_unquote_plus(quotedkey)
    val = urllib_unquote_plus(quotedval)
    res[key] = val

  return res
