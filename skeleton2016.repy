# ------------------------------------------------------------------------------     
# Start listening and handle incoming connections in board() function
# ------------------------------------------------------------------------------     
def start_board():
    ip = mycontext['ip']
    port = mycontext['port']
    print "Listening on IP " + str(ip) +" port " + str(port)
    try: 
        listencommhandle = waitforconn(ip, port, board_connection_handler)
    except Exception, e:
        print "Exception in start_board: %s, %s\n" %(type(e), e)
        raise
        #pass

# ------------------------------------------------------------------------------             
# Called when an incoming message is received. 
# --> Important starting point
# ------------------------------------------------------------------------------             
def board_connection_handler(ip, port, sockobj, thiscommhandle, listencommhandle):
    try:
        msgheader = sockobj.recv(1024) # Receive message

        # React depending on message type: HTTP GET or POST, or some other type of communication.
        if msgheader.startswith( 'GET' ):
            get_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'POST' ):
            post_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'ADD' ):
            add_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'MODIFY' ):
            modify_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'DELETE' ):
            delete_board_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'ELECTION' ):
            handle_election(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'LEADER' ):
            leader_handler(msgheader, sockobj, thiscommhandle)
        elif msgheader.startswith( 'PING' ):
            handle_ping(msgheader, sockobj, thiscommhandle)
        else:
            print '****Request:\n%s' % msgheader
            other_requests_handler(msgheader, sockobj, thiscommhandle)

    except Exception, e:
        print "Exception in board: %s, %s\n" %(type(e), e)
        #raise

# ------------------------------------------------------------------------------
# Handles initial GET request from browser, outputs HTML string and closes socket.
# ------------------------------------------------------------------------------
def get_board_handler(msgheader, sockobj, thiscommhandle):
    htmlresponse = generate_html_page()
    res=make_http_response(200, 'OK', htmlresponse)
    sockobj.send(res)
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles entry POSTing requests to the blackboard.
# If 'delete' is present in the query parameters,
# it will either delete or modify the entry.
# ------------------------------------------------------------------------------
def post_board_handler(msgheader, sockobj, thiscommhandle):
    template = '<html><head><style>.status {color: %s;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
    query = extract_http_request_contents(msgheader)
    params = extract_parameters_from_query(query)
    if 'entry' not in params:
        htmlresponse = template % ("red", "No entry in POST")
        res = make_http_response(400, 'Bad Request', htmlresponse)
        sockobj.send(res)
        stopcomm(thiscommhandle)
        return

    # Drop request if we have no leader
    if mycontext['leader'] is None:
        htmlresponse = template % ("red", "Network has no leader, try again later")
        res = make_http_response(202, 'Accepted', htmlresponse)
        sockobj.send(res)
        stopcomm(thiscommhandle)
        return

    # Extract msg
    msg = params['entry']

    # For debugging. Kill this node
    if msg == "exit":
        exitall()

    # Should we add, modify or delete?
    if 'delete' in params:
        msgid = int(params['id'])
        if params['delete'] == '1':
            delete_board_entry(msgid)
        else:
            modify_board_entry(msgid, msg)
    else:
        add_board_entry(msg)

    htmlresponse = template % ("green", "Post OK")
    res = make_http_response(200, 'OK', htmlresponse)
    sockobj.send(res)
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Helper function for add_board_entry.
# Return the largest key in the dictionary array xs.
# ------------------------------------------------------------------------------
def max_msgid(xs):
    maxid = 0
    for x in xs:
        if x > maxid:
            maxid = x
    return maxid

# ------------------------------------------------------------------------------
# If this node is the leader, it adds msg to the board and tells all other
# nodes about it.
# If this node is note the leader, it will ask the leader to add it.
# ------------------------------------------------------------------------------
def add_board_entry(msg):
    if is_leader():
        mycontext['board_lock'].acquire()
        try:
            msgid = max_msgid(mycontext['entries']) + 1
            mycontext['entries'][msgid] = msg
            send_to_neighbors('LEADER\nADD\n%d\n%s'
                % (msgid, urllib_quote_plus(msg)))
        finally:
            mycontext['board_lock'].release()
    else:
        send_to_leader('ADD\n%s' % (urllib_quote_plus(msg)))

# ------------------------------------------------------------------------------
# If this node is the leader, it modifies msgid
# and tells all other nodes about it.
# If this node is note the leader, it will ask the leader to modify it.
# ------------------------------------------------------------------------------
def modify_board_entry(msgid, msg):
    if is_leader():
        mycontext['board_lock'].acquire()
        try:
            if msgid in mycontext['entries']:
                mycontext['entries'][msgid] = msg
                send_to_neighbors('LEADER\nMODIFY\n%d\n%s'
                    % (msgid, urllib_quote_plus(msg)))
        finally:
            mycontext['board_lock'].release()
    else:
        send_to_leader('MODIFY\n%d\n%s' % (msgid, urllib_quote_plus(msg)))

# ------------------------------------------------------------------------------
# If this node is the leader, it deletes msgig from the board and tells all other
# nodes about it.
# If this node is note the leader, it will ask the leader to delete it.
# ------------------------------------------------------------------------------
def delete_board_entry(msgid):
    if is_leader():
        mycontext['board_lock'].acquire()
        try:
            if msgid in mycontext['entries']:
                del mycontext['entries'][msgid]
                send_to_neighbors('LEADER\nDELETE\n%d' % (msgid))
        finally:
            mycontext['board_lock'].release()
    else:
        send_to_leader('DELETE\n%d' % (msgid))

# ------------------------------------------------------------------------------
# Sends msg to all _other_ neighbors.
# ------------------------------------------------------------------------------
def send_to_neighbors(msg, silent=False):
    conns = []
    for neighbor in mycontext['neighborlist']:
        if neighbor['ip'] == mycontext['ip'] and \
                neighbor['port'] == mycontext['port']:
            continue
        try:
            nsock = openconn(neighbor['ip'], neighbor['port'])
            nsock.send(msg)
            conns.append(nsock)
        except Exception, e:
            if not silent:
                print "Exception in send_to_neighbors [%s:%d]: %s, %s\n" \
                    %(neighbor['ip'], neighbor['port'], type(e), e)
    for nsock in conns:
        try:
            # Assume we receive an "OK"
            rsock = nsock.recv(2)
            nsock.close()
        except Exception, e:
            if not silent:
                print "Exception in send_to_neighbors [%s:%d]: %s, %s\n" \
                    %(neighbor['ip'], neighbor['port'], type(e), e)

# ------------------------------------------------------------------------------
# Sends msg to the current leader.
# ------------------------------------------------------------------------------
def send_to_leader(msg):
    leader = None
    try:
        mycontext['election_lock'].acquire()
        leader = mycontext['leader']
    finally:
        mycontext['election_lock'].release()
    if leader is None:
        return
    try:
        nsock = openconn(leader['ip'], leader['port'])
        nsock.send(msg)
        rsock = nsock.recv(2)
        nsock.close()
    except Exception, e:
        print "Exception in send_to_leader, re-election! %s, %s\n" %(type(e), e)
        mycontext['election_lock'].acquire()
        mycontext['leader'] = None
        mycontext['election_lock'].release()
        start_election()

# ------------------------------------------------------------------------------
# Handles 'ADD' events. If this node is not the leader it will simply discard
# the event.
# ------------------------------------------------------------------------------
def add_board_handler(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    msg = urllib_unquote_plus(lines[1])
    if is_leader():
        add_board_entry(msg)
    sockobj.send('OK')
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles 'MODIFY' events. If this node is not the leader it will simply discard
# the event.
# ------------------------------------------------------------------------------
def modify_board_handler(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    msgid = int(lines[1])
    msg = urllib_unquote_plus(lines[2])
    if is_leader():
        modify_board_entry(msgid, msg)
    sockobj.send('OK')
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles 'DELETE' events. If this node is not the leader it will simply discard
# the event.
# ------------------------------------------------------------------------------
def delete_board_handler(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    msgid = int(lines[1])
    if is_leader():
        delete_board_entry(msgid)
    sockobj.send('OK')
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles 'LEADER' events. A 'LEADER' event is a message from the leader, and
# should always be followed, unless its submessage is 'NEW'. In that case
# it is another node announcing the new leader it found.
# ------------------------------------------------------------------------------
def leader_handler(msgheader, sockobj, thiscommhandle):
    lines = msgheader.splitlines()
    if lines[1] == 'NEW':
        new_leader = {
            'ip': lines[2],
            'port': int(lines[3]),
            'priority': float(lines[4])
        }
        try:
            mycontext['election_lock'].acquire()
            # Only accept the new leader if we don't have a leader,
            # if the new leader has a larger priority,
            # or if our current leader is unreachable.
            if mycontext['leader'] is None or \
                    mycontext['leader']['priority'] < new_leader['priority'] or \
                    not ping(mycontext['leader']):
                mycontext['leader'] = new_leader
        finally:
            mycontext['election_lock'].release()
    if lines[1] == 'ADD':
        msgid = int(lines[2])
        msg = urllib_unquote_plus(lines[3])
        mycontext['entries'][msgid] = msg
    elif lines[1] == 'MODIFY':
        msgid = int(lines[2])
        msg = urllib_unquote_plus(lines[3])
        mycontext['entries'][msgid] = msg
    elif lines[1] == 'DELETE':
        msgid = int(lines[2])
        del mycontext['entries'][msgid]
    else:
        print "Unknown method %s in leader_handler\n" % (lines[1])
    sockobj.send('OK')
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Handles other requests, outputs 404
# ------------------------------------------------------------------------------
def other_requests_handler(msgheader, sockobj, thiscommhandle):
    # extract the query from the HTTP request 
    query = extract_http_request_contents(msgheader)
    print query
    # extract the query parameters
    parameters = extract_parameters_from_query(query)
    print parameters
    print parameters['entry']

    # Do not mix HTML code with the server code as done here. This is a bad practice
    template='<html><head><style>.status {color: red;font-size: 75%%;}</style></head><body><pre><samp class="status">%s</samp></pre></body><html>'
    htmlresponse = template % ("404 Not Found\n" + msgheader)
    res=make_http_response(404, 'Not Found', htmlresponse)
    sockobj.send(res)
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Are we the leader in our centralized system?
# ------------------------------------------------------------------------------
def is_leader():
    return (mycontext['leader'] is not None and 
        mycontext['leader']['ip'] == mycontext['ip'] and 
        mycontext['leader']['port'] == mycontext['port'])

# ------------------------------------------------------------------------------
# Checks if we need to elect a new leader, preferably run this on a set interval
# Not currently used.
# ------------------------------------------------------------------------------
def should_elect_new_leader():
    if mycontext['leader'] is None:
        return True
    if is_leader():
        return False
    if mycontext['is_in_election']:
        return False
    if not ping(mycontext['leader']):
        return True
    return False

def ping(node):
    try:
        nsock = openconn(node['ip'], node['port'])
        nsock.send("PING")
        rsock = nsock.recv(4)
        nsock.close()
        return rsock == "PONG"
    except Exception, e:
        return False

def handle_ping(msgheader, sockobj, thiscommhandle):
    sockobj.send("PONG")
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Used for debugging purposes. Adds a new log entry to the board.
# ------------------------------------------------------------------------------
def log(msg):
    if 'logid' not in mycontext:
        mycontext['logid'] = -1
    mycontext['entries'][mycontext['logid']] = msg
    mycontext['logid'] = mycontext['logid'] - 1

# ------------------------------------------------------------------------------
# Starts an election by sending an 'ELECTION' event to the next available
# neighbor.
# ------------------------------------------------------------------------------
def start_election():
    try:
        mycontext['election_lock'].acquire()
        if mycontext['is_in_election']:
            return
        mycontext['is_in_election'] = True
    finally:
        mycontext['election_lock'].release()
    election_str = "ELECTION\n%s %d %f" \
        % (mycontext['ip'], mycontext['port'], mycontext['election_priority'])
    if not send_to_next_in_election_ring(election_str, priority=False):
        # No other nodes responded, so we are the sole survivor in our network
        try:
            mycontext['election_lock'].acquire()
            mycontext['is_in_election'] = False
            leader = {
                'ip': mycontext['ip'],
                'port': mycontext['port'],
                'priority': mycontext['election_priority']
            }
            mycontext['leader'] = leader
        finally:
            mycontext['election_lock'].release()

# ------------------------------------------------------------------------------
# Sends election_str to the first available neighbor.
# Tries all neighbors until one could be reached.
#
# If priority is not set it will not use the neighbor list that is sorted by
# priority. This is used by the election algorithm, as we don't really care
# who we send it to.
# ------------------------------------------------------------------------------
def send_to_next_in_election_ring(election_str, priority=True):
    local_neighborlist_election = mycontext['neighborlist_election']
    if not priority:
        local_neighborlist_election = None
    my_index = get_index_in_election_ring()
    candidate_index = my_index
    while True:
        candidate_index = get_next_in_election_ring(
            local_neighborlist_election,
            candidate_index)
        if candidate_index == my_index:
            return False
        candidate = mycontext['neighborlist'][candidate_index]
        if send_to_node(candidate, election_str):
            return True

# ------------------------------------------------------------------------------
# Gets our position in the neighbor list.
# ------------------------------------------------------------------------------
def get_index_in_election_ring():
    for idx in range(len(mycontext['neighborlist'])):
        neighbor = mycontext['neighborlist'][idx]
        if neighbor['ip'] == mycontext['ip'] and neighbor['port'] == mycontext['port']:
            return idx
    raise Exception('Node not in neighborlist\n%s:%d\n%s'
        % (mycontext['ip'], mycontext['port'], str(mycontext['neighborlist'])))

# ------------------------------------------------------------------------------
# Gets the next neighbor in either the neighbor list or the neighbor list
# sorted by priority.
# ------------------------------------------------------------------------------
def get_next_in_election_ring(local_neighborlist_election, neighbor_idx):
    if local_neighborlist_election is None:
        neighbor_idx = neighbor_idx + 1
        return neighbor_idx % len(mycontext['neighborlist'])
    else:
        election_idx = idx_index_of(local_neighborlist_election, neighbor_idx)
        if election_idx is None:
            raise Exception('BOOOORK')
        election_idx = election_idx + 1
        if election_idx == len(local_neighborlist_election):
            # We should ignore those who are beneath us
            return get_index_in_election_ring()
        return local_neighborlist_election[election_idx]['idx']

# ------------------------------------------------------------------------------
# Sends msg to node.
# ------------------------------------------------------------------------------
def send_to_node(node, msg):
    try:
        nsock = openconn(node['ip'], node['port'])
        nsock.send(msg)
        rsock = nsock.recv(2)
        nsock.close()
        return True
    except Exception, e:
        print "Exception in send_to_node: %s, %s\n" %(type(e), e)
        return False

# ------------------------------------------------------------------------------
# Handles 'ELECTION' events.
# ------------------------------------------------------------------------------
def handle_election(msgheader, sockobj, thiscommhandle):
    candidates = msgheader.splitlines()[1:]
    if candidates[0].startswith("%s %d" % (mycontext['ip'], mycontext['port'])):
        new_leader = None
        try:
            mycontext['election_lock'].acquire()
            # Our election has come back to us
            if mycontext['is_in_election']:
                mycontext['is_in_election'] = False
                results = []
                for candi in candidates:
                    candistr = candi.split(' ')
                    candii = {
                        'ip': candistr[0],
                        'port': int(candistr[1]),
                        'priority': float(candistr[2])
                    }
                    idx = ipport_index_of(mycontext['neighborlist'], candii)
                    candii['idx'] = idx
                    results.append(candii)
                results.sort(reverse = True, key = itemgetter_priority)
                # Save the results for future use when deciding closes neighbor
                mycontext['neighborlist_election'] = results
                new_leader = results[0]
                if mycontext['leader'] is None or \
                        mycontext['leader']['priority'] < new_leader['priority']:
                    mycontext['leader'] = new_leader
                else:
                    new_leader = None
        finally:
            mycontext['election_lock'].release()
        if new_leader is not None:
            send_to_neighbors("LEADER\nNEW\n%s\n%d\n%f"
                % (new_leader['ip'], new_leader['port'], new_leader['priority']))
    else:
        # Append us to the election list
        msgheader = msgheader + "\n%s %d %f" \
            % (mycontext['ip'], mycontext['port'], mycontext['election_priority'])
        send_to_next_in_election_ring(msgheader, priority=False)
    sockobj.send('OK')
    stopcomm(thiscommhandle)

# ------------------------------------------------------------------------------
# Helper method for get_next_in_election_ring.
# Returns the position of x in xs' 'idx' entry. 
# ------------------------------------------------------------------------------
def idx_index_of(xs, x):
    for idx in range(len(xs)):
        xx = xs[idx]
        if xx['idx'] == x:
            return idx
    return None

# ------------------------------------------------------------------------------
# Helper method for handle_election.
# Returns the position in xs where ip and port is equal to x
# ------------------------------------------------------------------------------
def ipport_index_of(xs, x):
    for idx in range(len(xs)):
        xx = xs[idx]
        if xx['ip'] == x['ip'] and xx['port'] == x['port']:
            return idx
    return None

# ------------------------------------------------------------------------------
# Helper method for handle_election.
# ------------------------------------------------------------------------------
def itemgetter_priority(x):
    return x['priority']

# ------------------------------------------------------------------------------
# Wrap into HTTP headers
# ------------------------------------------------------------------------------
def make_http_response(status, status_text, htmlresponse):
    response_template = "HTTP/1.1 %d %s\r\nContent-type: text/html\r\nContent-length: %i\r\n\r\n%s"
    return response_template % (status, status_text, len(htmlresponse), htmlresponse)

# ------------------------------------------------------------------------------
# Utility function to extract the contents (payload) from HTTP request
# ------------------------------------------------------------------------------
def extract_http_request_contents(header):
    # find content length
    conent_length = header.split('Content-Length: ')[1]
    conent_length = int(conent_length.split('\r\n')[0])

    # extract the http response body and discard the header
    contetns = header[-conent_length:]
    return contetns

# ------------------------------------------------------------------------------
# Utility function to extract query parameter from HTML query
# ------------------------------------------------------------------------------
def extract_parameters_from_query(msg):
    # extract the query parameters as a dictionary: {name:value}
    # example input format: comment=aa&ip=127.0.0.1&port=63101&action=Delete
    parameters={}
    arr = msg.split('&')
    for a in arr:
        pp = a.split('=')
        if len(pp)>1:
            parameters[pp[0]] = urllib_unquote_plus(pp[1])
    return parameters

# ------------------------------------------------------------------------------
# Outputs the blackboard html 
# ------------------------------------------------------------------------------     
def generate_html_page():
    #Initialize blackboard content

    entries = []
    for msgid in mycontext['entries']:
        msg = mycontext['entries'][msgid]
        entries.append(mycontext['entry_template'] %('entries/%d' % (msgid), msgid, msg))
    entriesStr = "".join(entries)

    # dynamic title showing Ip address, port and up time. 
    leader_title = "Board"
    if mycontext['leader'] is not None:
        if is_leader():
            leader_title = "LEADER"
        leader = 'Current leader: %s:%d [%f]' \
            % (mycontext['leader']['ip'],
               mycontext['leader']['port'],
               mycontext['leader']['priority'])
    elif mycontext['is_in_election']:
        leader = 'Election in progress...'
    else:
        leader = 'No current leader'

    title='%s [%f] @ %s:%d. Up time: %d' \
        %( leader_title,
           mycontext['election_priority'],
           str(mycontext['ip']),
           mycontext['port'],
           int(getruntime()) )
    content = mycontext['boardcontents_template'] %( title, leader, entriesStr )
    fullpage_h = mycontext['frontpage_header_template'] + content
    fullpage = fullpage_h + mycontext['frontpage_footer_template'] % mycontext['authors']
    #print entriesStr, content, fullpage
    return fullpage


# ------------------------------------------------------------------------------
# Create all variables that we assume exists
# ------------------------------------------------------------------------------     
def init_env():
    # Empty blackboard
    mycontext['entries'] = {}

    # Read neighbors
    # neighborlist contains ourself as well, which is important to remember
    mycontext['neighborlist'] = []
    for neighbor in file("neighborlist.txt").read().splitlines():
        ipport = neighbor.split(':')
        nip = ipport[0]
        nport = int(ipport[1])
        mycontext['neighborlist'].append({'ip': nip, 'port': nport})

    mycontext['board_lock'] = getlock()
    mycontext['election_lock'] = getlock()
    mycontext['leader'] = None
    mycontext['is_in_election'] = False
    mycontext['election_priority'] = randomfloat()
    mycontext['neighborlist_election'] = None


# ------------------------------------------------------------------------------             
# Main entry point of the program. Initalizes global variables in mycontext
# and calls start_board() which opens a socket for incoming connections.
# ------------------------------------------------------------------------------
if callfunc == 'initialize':
    # whenever this vessel gets a connection on its IP:port it'll call function board_connection_handler
    if len(callargs) == 1 or len(callargs) == 2:
        port = int(callargs[0])
        if len(callargs) == 2:
            ip=str(callargs[1])
        else:
            try:
             ip = getmyip()
            except Exception, e:
             print "Could not get an IP\n"
             print (type(e), e)
             raise

    # Fail if we don't have 1 or 2 arguments    
    else:
        raise Exception("Usage: python <path to repy.py> <path to restrictions.default> skeleton2016.repy <port> [ip (optional)]")

    #Initialize Port and IP
    mycontext['port'] = port
    mycontext['ip'] = ip

    #read html template files
    mycontext['entry_template'] = file("entry_template.html").read()
    mycontext['boardcontents_template'] = file("boardcontents_template.html").read()
    mycontext['frontpage_header_template'] = file("board_frontpage_header_template.html").read()
    mycontext['frontpage_footer_template'] = file("board_frontpage_footer_template.html").read()

    mycontext['authors'] = "Rafael Mohlin (mrafael@student.chalmers.se)"

    init_env()

    # e = Exception("ex");
    # try:
    # print "%s, %s\n" %(type(e), e)
    # except Exception, ee:
    # print ee

    start_board()

    # We should always start an election when we first spawn
    # but wait until all nodes are up
    #settimer(10, start_election, [])
    start_election()

# ----------------------------------------------------------------------------
# urllib.repy
# include urllib.repy doesn't work, if fails with the error
# Exception (with type 'exceptions.ValueError'): Code failed safety check! Error: ("<type 'exceptions.SyntaxError'> invalid syntax (line lineNrAfterIncludeStatment)",)

def urllib_quote(inputstring, safestring="/"):
  """
  <Purpose>
    Encode an inputstring such that it can be used safely in a URL or XML
    document.

  <Arguments>
    inputstring:
           The string to urlencode.

    safestring (optional):
           Specifies additional characters that should not be quoted --
           defaults to "/".

  <Exceptions>
    TypeError if the inputstring or safestring parameters aren't strings.

  <Side Effects>
    None.

  <Returns>
    Urlencoded version of the passed string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_quote's inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  if type(safestring) is not str:
    raise TypeError("urllib_quote's safestring parameter must be a string, not '"+str(type(safestring))+"'")
  

  resultstr = ""

  # We go through each character in the string; if it's not in [0-9a-zA-Z]
  # we wrap it.

  safeset = set(safestring)

  for char in inputstring:
    asciicode = ord(char)
    if (asciicode >= ord("0") and asciicode <= ord("9")) or \
        (asciicode >= ord("A") and asciicode <= ord("Z")) or \
        (asciicode >= ord("a") and asciicode <= ord("z")) or \
        asciicode == ord("_") or asciicode == ord(".") or \
        asciicode == ord("-") or char in safeset:
      resultstr += char
    else:
      resultstr += "%%%02X" % asciicode

  return resultstr




def urllib_quote_plus(inputstring, safestring=""):
  """
  <Purpose>
    Encode a string to go in the query fragment of a URL.

  <Arguments>
    inputstring:
           The string to urlencode.

    safestring (optional):
           Specifies additional characters that should not be quoted --
           defaults to the empty string.

  <Exceptions>
    TypeError if the inputstring or safestring parameters aren't strings.

  <Side Effects>
    None.

  <Returns>
    Urlencoded version of the passed string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_quote_plus' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  if type(safestring) is not str:
    raise TypeError("urllib_quote_plus' safestring parameter must be a string, not '"+str(type(safestring))+"'")
  

  return urllib_quote(inputstring, safestring + " ").replace(" ", "+")




def urllib_unquote(inputstring):
  """
  <Purpose>
    Unquote a urlencoded string.

  <Arguments>
    inputstring:
           The string to unquote.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError thrown if the last wrapped octet isn't a valid wrapped octet
    (i.e. if the string ends in "%" or "%x" rather than "%xx". Also throws
    ValueError if the nibbles aren't valid hex digits.

  <Side Effects>
    None.

  <Returns>
    The decoded string.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_unquote's inputstring parameter must be a string, not '"+str(type(inputstring))+"'")
  

  resultstr = ""

  # We go through the inputstring from end to beginning, looking for wrapped
  # octets. When one is found we add it (unwrapped) and the following
  # string to the resultant string, and shorten the original inputstring.

  while True:
    lastpercentlocation = inputstring.rfind("%")
    if lastpercentlocation < 0:
      break

    wrappedoctetstr = inputstring[lastpercentlocation+1:lastpercentlocation+3]
    if len(wrappedoctetstr) != 2:
      raise ValueError("Quoted string is poorly formed")

    resultstr = \
        chr(int(wrappedoctetstr, 16)) + \
        inputstring[lastpercentlocation+3:] + \
        resultstr
    inputstring = inputstring[:lastpercentlocation]

  resultstr = inputstring + resultstr
  return resultstr




def urllib_unquote_plus(inputstring):
  """
  <Purpose>
    Unquote the urlencoded query fragment of a URL.

  <Arguments>
    inputstring:
           The string to unquote.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError thrown if the last wrapped octet isn't a valid wrapped octet
    (i.e. if the inputstring ends in "%" or "%x" rather than "%xx". Also throws
    ValueError if the nibbles aren't valid hex digits.

  <Side Effects>
    None.

  <Returns>
    The decoded string.
  """
  if type(inputstring) is not str:
    raise TypeError("urllib_unquote_plus' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")

  return urllib_unquote(inputstring.replace("+", " "))




def urllib_quote_parameters(inputdictionary):
  """
  <Purpose>
    Encode a dictionary of (key, value) pairs into an HTTP query string or
    POST body (same form).

  <Arguments>
    dictionary:
           The dictionary to quote.

  <Exceptions>
    TypeError if the inputdictionary isn't a dict.

  <Side Effects>
    None.

  <Returns>
    The quoted dictionary.
  """
  if type(inputdictionary) is not dict:
    raise TypeError("urllib_quote_parameters' inputstringdictionary parameter must be a dict, not '"+str(type(inputstring))+"'")

  quoted_keyvals = []
  for key, val in inputdictionary.items():
    quoted_keyvals.append("%s=%s" % (urllib_quote(key), urllib_quote(val)))

  return "&".join(quoted_keyvals)




def urllib_unquote_parameters(inputstring):
  """
  <Purpose>
    Decode a urlencoded query string or POST body.

  <Arguments>
    inputstring:
           The string to decode.

  <Exceptions>
    TypeError if the inputstring isn't a string
    ValueError if the inputstring is poorly formed.

  <Side Effects>
    None.

  <Returns>
    A dictionary mapping keys to values.
  """

  if type(inputstring) is not str:
    raise TypeError("urllib_unquote_parameters' inputstring parameter must be a string, not '"+str(type(inputstring))+"'")

  keyvalpairs = inputstring.split("&")
  res = {}

  for quotedkeyval in keyvalpairs:
    # Throw ValueError if there is more or less than one '='.
    quotedkey, quotedval = quotedkeyval.split("=")
    key = urllib_unquote_plus(quotedkey)
    val = urllib_unquote_plus(quotedval)
    res[key] = val

  return res
